# CS230 Software Design Document 

Briefly summarize The Gaming Room client and their software requirements. Who was the client? What type of software did they want you to design?


The client, The Gaming Room, sought assistance in developing software for their popular game, Draw It or Lose It. They aimed to transition the game from an Android app to a web-based platform to broaden its accessibility and appeal across various devices and platforms. The software requirements included support for multiple teams, unique game and team names, and implementing the singleton design pattern to ensure optimal performance.

---------------------------------------------------------------------------------------------------
What did you do particularly well in developing this documentation?

In creating this documentation, I outlined the client’s needs, suggested appropriate solutions, and explained complex technical concepts clearly. I followed a well-structured format throughout, systematically addressing every aspect of the project and ensuring consistency between sections. I also customized the language and the level of detail to ensure that the information was easy to understand while staying technically accurate. All in all, my approach was clear, concise, and relevant to the client's requirements to create well-rounded documentation.

---------------------------------------------------------------------------------------------------
What about the process of working through a design document did you find helpful when developing the code?


Working with the design document helped me by providing a clear roadmap and reference for understanding the client's requirements. It also helped in breaking down the project into manageable components, identifying potential challenges upfront, and facilitating better planning and task prioritization during coding. 

---------------------------------------------------------------------------------------------------
If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?

I would revise the evaluation portion. After further rearch and completing the document, I have a deeper understanding of each platform. I would provide a more thorough and nuanced analysis of the characteristics, advantages, and weaknesses of each operating platform.

---------------------------------------------------------------------------------------------------
How did you interpret the user’s needs and implement them into your software design? Why is it so important to consider the user’s needs when designing?

In interpreting the user's needs, I focused on recognizing their requirements and limitations, which formed the basis for my recommendations. Understanding the user's goals, preferences, and constraints was vital in designing software that effectively addressed their needs. By taking into account the user's perspective, I aimed to develop solutions that not only solved their problems but also enhanced their overall experience. Neglecting the user's needs in software design can result in usability issues, inefficiencies, and dissatisfaction. Conversely, adopting a user-centered design approach ensures that the software meets its intended purpose, delivers value to users, and achieves success in its implementation.

---------------------------------------------------------------------------------------------------
How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application?


When I design software, I begin by understanding the project’s needs and goals. Once I understand the goals and limitations, I start the design process. One of the ways I design software is by creating flowcharts. Flowcharts help me understand the structure and how different software components interact with each other. This helps me to identify dependencies, define interfaces, and understand the overall structure of the system. I also break down requirements into smaller, easier-to-implement tasks or modules. This makes it easier to implement and test.
